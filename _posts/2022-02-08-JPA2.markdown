---
title: "Spring Boot - JPA 프로그래밍 (2)"
excerpt: "Spring Data, JPA 프로그래밍 공부 노트"

header:
  overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
  overlay_filter: 0.5

tags:
  - Java
  - Spring Boot
  - JPA

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

# 연관 관계 (Entity Relations)

## 1:1 연관 관계

책과 책에 대한 리뷰의 종합 정보가 있다고 하자. 책에 대한 종합 정보는 "평점 평균", "총 리뷰 수" 등의 정보를 포함하고 있다. 이는 딱 한 책에 대한 정보만 가질 수 있으므로 1:1 관계라고 할 수 있음.

```java
import lombok.*;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
@NoArgsConstructor
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class Book extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String category;

  private Long authorId;

  private Long publisherId;
}
```

Book 은 이렇게 생겼고

```java
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.persistence.*;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class BookReviewInfo extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @OneToOne   // 연관관계의 설정 (1:1)
  private Book book;

  private float averageReviewScore;
  // private Float averageReviewScore;  -> null 값을 허용한다면 이 코드

  private int reviewCount;
  // private Integer reviewCount;  -> null 값을 허용한다면 이 코드
}
```

BookReviewInfo 는 이렇게 생김.

'id' column의 GeneratedValue 설정이 바뀜. 기존 strategy 값이 `GenerationType.AUTO` 이던 default 값에서 `GenerationType.IDENTITY` 로 바꾸면서 각 테이블이 각 고유번호를 가지게 함. 기존에는 `hibernate_sequece` 로 sequence 를 전역에서 잡았기 때문에 전체 db에서의 고유값을 가졌는데, 이제는 table 내부에서만의 고유값을 가짐.

`@OneToOne` 이라는 어노테이션을 통해 Book 객체와의 연관관계를 설정 했음. 관계형 데이터베이스에서 외래키를 설정했다고 생각하면 될 것 같음.. H2 DB 의 query 로는 아래와 같은 쿼리로 테이블이 생성되게 된다.

```shell
create table book_review_info (
    id bigint generated by default as identity,
    created_at timestamp,
    updated_at timestamp,
    average_review_score float not null,
    review_count integer not null,
    book_id bigint,
    primary key (id)
)
```

Book 객체를 통째로 column에 적용하였음에도 불구하고 `bookId` 가 column 으로 지정된 것을 알 수 있음.

간단히 아래와 같이 테스트를 해보자.

```java
import com.fastcampus.jpa.bookmanager.domain.Book;
import com.fastcampus.jpa.bookmanager.domain.BookReviewInfo;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class BookReviewInfoRepositoryTest {
  @Autowired
  private BookReviewInfoRepository bookReviewInfoRepository;

  @Autowired
  private BookRepository bookRepository;

  private Book givenBook() {
    Book book = new Book();
    book.setName("Jpa 초격차 패키지");
    book.setAuthorId(1L);
    book.setPublisherId(1L);

    return bookRepository.save(book);
  }

  private BookReviewInfo givenBookReviewInfo() {
    BookReviewInfo bookReviewInfo = new BookReviewInfo();
    bookReviewInfo.setBook(givenBook());
    bookReviewInfo.setAverageReviewScore(4.5f);
    bookReviewInfo.setReviewCount(2);

    return bookReviewInfoRepository.save(bookReviewInfo);
  }

  @Test
  void crudTest() {
    givenBookReviewInfo();

    System.out.println(">>>1 " + bookReviewInfoRepository.findAll());

    Book result = bookReviewInfoRepository.findById(1L).orElseThrow(RuntimeException::new).getBook();

    System.out.println(">>>2 " + result);
  }
}
```

1. `givenBook()` 메서드로 Book 을 하나 만들어서
2. `givenBookReview()` 메서드에 `setBook` 에 book 을 셋해줌
3. 1번 결과 출력으로 아래와 같은 게 찍힘

```shell
>>>1 [BookReviewInfo(super=BaseEntity(createdAt=2022-03-03T10:50:26.498, updatedAt=2022-03-03T10:50:26.498), id=1, book=Book(super=BaseEntity(createdAt=2022-03-03T10:50:26.445, updatedAt=2022-03-03T10:50:26.445), id=1, name=Jpa 초격차 패키지, category=null, authorId=1, publisherId=1), averageReviewScore=4.5, reviewCount=2)]
```

만들어진 book 객체가 잘 들어감.

4. `bookReviewInfo` 레파지토리에서 id:1 에 해당하는 필드에 book 을 가져오기 위한 쿼리가 어떻게 동작했는지 살펴보장.

```shell
select
    bookreview0_.id as id1_2_0_,
    bookreview0_.created_at as created_2_2_0_,
    bookreview0_.updated_at as updated_3_2_0_,
    bookreview0_.average_review_score as average_4_2_0_,
    bookreview0_.book_id as book_id6_2_0_,
    bookreview0_.review_count as review_c5_2_0_,
    book1_.id as id1_1_1_,
    book1_.created_at as created_2_1_1_,
    book1_.updated_at as updated_3_1_1_,
    book1_.author_id as author_i4_1_1_,
    book1_.category as category5_1_1_,
    book1_.name as name6_1_1_,
    book1_.publisher_id as publishe7_1_1_
from
    book_review_info bookreview0_
left outer join
    book book1_
        on bookreview0_.book_id=book1_.id
where
    bookreview0_.id=?
```

LEFT OUTER JOIN 을 통해서 Book Entity 와의 결합이 이루어지는 걸 볼 수 있음.

5. 그래서 그 결과로 책리뷰 id:1 필드의 Book 정보를 쏙 꺼낸 결과가 아래와 같다.

```shell
>>>2 Book(super=BaseEntity(createdAt=2022-03-03T10:50:26.445, updatedAt=2022-03-03T10:50:26.445), id=1, name=Jpa 초격차 패키지, category=null, authorId=1, publisherId=1)
```

지금은 LEFT OUTER JOIN 을 했다. 이는 Book 이 null 값이 되는 것을 허용하고 있다는 것을 전제로 한다. 실제로 더 위에서 살펴본 create table 쿼리를 보면 book_id 에는 not null 설정이 들어가 있지 않다. null 을 허용하지 않기 위해서는 `@OneToOne` 어노테이션에 `optional = false` 옵션을 주면 됨. => `@OneToOne(optional = false)`

옵션을 바꾸고 쿼리를 살펴보면 조금 변한다.

```shell
create table book_review_info (
    id bigint generated by default as identity,
    created_at timestamp,
    updated_at timestamp,
    average_review_score float not null,
    review_count integer not null,
    book_id bigint not null,
    primary key (id)
)
```

book_id 에 not null 옵션이 붙고

```shell
select
    bookreview0_.id as id1_2_0_,
    bookreview0_.created_at as created_2_2_0_,
    bookreview0_.updated_at as updated_3_2_0_,
    bookreview0_.average_review_score as average_4_2_0_,
    bookreview0_.book_id as book_id6_2_0_,
    bookreview0_.review_count as review_c5_2_0_,
    book1_.id as id1_1_1_,
    book1_.created_at as created_2_1_1_,
    book1_.updated_at as updated_3_1_1_,
    book1_.author_id as author_i4_1_1_,
    book1_.category as category5_1_1_,
    book1_.name as name6_1_1_,
    book1_.publisher_id as publishe7_1_1_
from
    book_review_info bookreview0_
inner join
    book book1_
        on bookreview0_.book_id=book1_.id
where
    bookreview0_.id=?
```

`getBook()` 을 할 때는 INNER JOIN 이 들어간 것을 볼 수 있다.

지금까지 `BookReviewInfo` 에서 책 정보를 가져오는 예시를 만들었다. 반대로 `Book` 에서 책 리뷰 정보를 가져오는 것을 해보자. 여기서는 조금 주의해야 할 것이 있다.

위에서 구현한대로 `Book` entity 를 구현해버리면 약간 문제가 생김.

```java
import lombok.*;

import javax.persistence.*;

@Entity
@NoArgsConstructor
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class Book extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String category;

  private Long authorId;

  private Long publisherId;

  @OneToOne
  private BookReviewInfo bookReviewInfo;
}
```

테스트 코드

```java
import com.fastcampus.jpa.bookmanager.domain.Book;
import com.fastcampus.jpa.bookmanager.domain.BookReviewInfo;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class BookReviewInfoRepositoryTest {
  @Autowired
  private BookReviewInfoRepository bookReviewInfoRepository;

  @Autowired
  private BookRepository bookRepository;

  private Book givenBook() {
    Book book = new Book();
    book.setName("Jpa 초격차 패키지");
    book.setAuthorId(1L);
    book.setPublisherId(1L);

    return bookRepository.save(book);
  }

  private BookReviewInfo givenBookReviewInfo() {
    BookReviewInfo bookReviewInfo = new BookReviewInfo();
    bookReviewInfo.setBook(givenBook());
    bookReviewInfo.setAverageReviewScore(4.5f);
    bookReviewInfo.setReviewCount(2);

    return bookReviewInfoRepository.save(bookReviewInfo);
  }

  @Test
  void crudTest() {
    givenBookReviewInfo();

    System.out.println(">>>1 " + bookReviewInfoRepository.findAll());

    Book result = bookReviewInfoRepository.findById(1L).orElseThrow(RuntimeException::new).getBook();

    System.out.println(">>>2 " + result);

    BookReviewInfo result2 = bookRepository
        .findById(1L)
        .orElseThrow(RuntimeException::new)
        .getBookReviewInfo();

    System.out.println(">>>3 " + result2);
  }
}
```

Book repository 에서 BookReviewInfo 를 가져와보자. 어떤 select 쿼리가 동작하는가 보아하니

```shell
select
    book0_.id as id1_1_0_,
    book0_.created_at as created_2_1_0_,
    book0_.updated_at as updated_3_1_0_,
    book0_.author_id as author_i4_1_0_,
    book0_.book_review_info_id as book_rev8_1_0_,
    book0_.category as category5_1_0_,
    book0_.name as name6_1_0_,
    book0_.publisher_id as publishe7_1_0_,
    bookreview1_.id as id1_2_1_,
    bookreview1_.created_at as created_2_2_1_,
    bookreview1_.updated_at as updated_3_2_1_,
    bookreview1_.average_review_score as average_4_2_1_,
    bookreview1_.book_id as book_id6_2_1_,
    bookreview1_.review_count as review_c5_2_1_,
    book2_.id as id1_1_2_,
    book2_.created_at as created_2_1_2_,
    book2_.updated_at as updated_3_1_2_,
    book2_.author_id as author_i4_1_2_,
    book2_.book_review_info_id as book_rev8_1_2_,
    book2_.category as category5_1_2_,
    book2_.name as name6_1_2_,
    book2_.publisher_id as publishe7_1_2_
from
    book book0_
left outer join
    book_review_info bookreview1_
        on book0_.book_review_info_id=bookreview1_.id
left outer join
    book book2_
        on bookreview1_.book_id=book2_.id
where
    book0_.id=?
```

JOIN 이 2번 일어난다. 딱 봐도 효율적이지 않아 보인다. 이를 해결하기 위해서 `@OneToOne` 에 `mappedBy` 옵션을 주자.

```java
import lombok.*;

import javax.persistence.*;

@Entity
@NoArgsConstructor
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class Book extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String category;

  private Long authorId;

  private Long publisherId;

  @OneToOne(mappedBy = "book")
  @ToString.Exclude
  private BookReviewInfo bookReviewInfo;
}
```

Book 객체를 BookReviewInfo 객체에 멤버 변수 'book' 에 mapping 하겠다는 의미. 이 코드에서 `@ToString.Exclude` 를 추가하였다. 이 어노테이션을 작성하지 않으면 `StackOverflowError` 가 발생한다. 이는 관계를 맺은 두 엔티티가 서로 `toString()` 을 호출하면서 무한 반복되기 때문.

테스트를 돌려보자.

```shell
select
    book0_.id as id1_1_0_,
    book0_.created_at as created_2_1_0_,
    book0_.updated_at as updated_3_1_0_,
    book0_.author_id as author_i4_1_0_,
    book0_.category as category5_1_0_,
    book0_.name as name6_1_0_,
    book0_.publisher_id as publishe7_1_0_,
    bookreview1_.id as id1_2_1_,
    bookreview1_.created_at as created_2_2_1_,
    bookreview1_.updated_at as updated_3_2_1_,
    bookreview1_.average_review_score as average_4_2_1_,
    bookreview1_.book_id as book_id6_2_1_,
    bookreview1_.review_count as review_c5_2_1_
from
    book book0_
left outer join
    book_review_info bookreview1_
        on book0_.id=bookreview1_.book_id
where
    book0_.id=?
```

2번 JOIN 일어나는 일이 없어졌다.

<br/>

## 1:N 연관 관계

유저 - 유저 히스토리는 1:N 의 관계라 할 수 있다. 구현해보자.

```java
import com.fastcampus.jpa.bookmanager.domain.User;
import com.fastcampus.jpa.bookmanager.domain.UserHistory;
import com.fastcampus.jpa.bookmanager.repository.UserHistoryRepository;
import com.fastcampus.jpa.bookmanager.support.BeanUtils;

import javax.persistence.PostPersist;
import javax.persistence.PostUpdate;

public class UserEntityListener {
  @PostPersist
  @PostUpdate
  public void prePersistAndPreUpdate(Object o) {
    UserHistoryRepository userHistoryRepository = BeanUtils.getBean(UserHistoryRepository.class);

    User user = (User) o;

    UserHistory userHistory = new UserHistory();
    userHistory.setUserId(user.getId());
    userHistory.setName(user.getName());
    userHistory.setEmail(user.getEmail());

    userHistoryRepository.save(userHistory);
  }
}
```

```java
import com.fastcampus.jpa.bookmanager.domain.listener.UserEntityListener;
import lombok.*;

import javax.persistence.*;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@Builder
@Entity
@EntityListeners(value = UserEntityListener.class)
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @NonNull
  private String name;

  @NonNull
  private String email;

  @Enumerated(EnumType.STRING)
  private Gender gender;
}
```

```java
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class UserHistory extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private Long userId;

  private String name;

  private String email;
}
```

테스트 코드

```java
package com.fastcampus.jpa.bookmanager.repository;

import com.fastcampus.jpa.bookmanager.domain.Gender;
import com.fastcampus.jpa.bookmanager.domain.User;
import com.fastcampus.jpa.bookmanager.domain.UserHistory;
import org.assertj.core.util.Lists;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;

import java.time.LocalDateTime;
import java.util.List;

@SpringBootTest
class UserRepositoryTest {

  @Autowired
  private UserRepository userRepository;

  @Autowired
  private UserHistoryRepository userHistoryRepository;

  @Test
  void userRelationTest() {
    User user = new User();
    user.setName("david");
    user.setEmail("david@fastcampus.com");
    user.setGender(Gender.MALE);
    userRepository.save(user);
    user.setName("daniel");
    userRepository.save(user);
    user.setEmail("daniel@fastcampus.com");
    userRepository.save(user);

    List<UserHistory> result = userHistoryRepository.findByUserId(userRepository.findByEmail("daniel@fastcampus.com").getId());

    result.forEach(System.out::println);
  }
}
```

작성한 EntityListener 가 동작하면서 3개의 UserHistory 가 쌓인 것을 볼 수 있다.

```shell
UserHistory(super=BaseEntity(createdAt=2022-03-03T14:10:59.116, updatedAt=2022-03-03T14:10:59.116), id=1, userId=6, name=david, email=david@fastcampus.com)
UserHistory(super=BaseEntity(createdAt=2022-03-03T14:10:59.156, updatedAt=2022-03-03T14:10:59.156), id=2, userId=6, name=daniel, email=david@fastcampus.com)
UserHistory(super=BaseEntity(createdAt=2022-03-03T14:10:59.160, updatedAt=2022-03-03T14:10:59.160), id=3, userId=6, name=daniel, email=daniel@fastcampus.com)
```

이렇게 작성하는 것도 가능하긴 함. 이젠 `@OneToOne` 어노테이션을 쓴 것처럼 1:N의 관계도 어노테이션을 사용하여 구현해보장

```java
import com.fastcampus.jpa.bookmanager.domain.listener.UserEntityListener;
import lombok.*;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;


@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
@Data
@Builder
@Entity
@EntityListeners(value = UserEntityListener.class)
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @NonNull
  private String name;

  @NonNull
  private String email;

  @Enumerated(EnumType.STRING)
  private Gender gender;

  @OneToMany(fetch = FetchType.EAGER)
  @JoinColumn(name = "user_id", insertable = false, updatable = false)
  private List<UserHistory> userHistories = new ArrayList<>();
}
```

`@OneToMany` 어노테이션을 사용한다. fetch 속성에 대해서는 나중에 알려주신다고 하신다. 그 아래에 `@JoinColumn` 어노테이션을 사용했다. 이 어노테이션은 외래키를 매핑할 때 사용한다.

`@JoinColumn` 을 작성하지 않고 테스트를 돌린 후 DDL 을 살펴보면

```shell
create table user_user_histories (
    user_id bigint not null,
    user_histories_id bigint not null
)
```

만들지도 않은 user_user_histories 라는 테이블이 생기는 것을 볼 수 있다. 실제 존재하는 entity 와 매핑을 해주지 않았기 때문에 JPA 가 새로운 테이블이 필요한 것으로 인식하고 새로 만드는 듯.

`@JoinColumn` 의 속성을 뜯어보자. name 속성을 넣었는데, 이는 매핑할 외래키의 이름을 말한다. 기본값으로는 `필드명_참조테이블의 기본키명` 이기 때문에 이 상태로 그냥 테스트를 돌리면 에러가 발생한다.

```shell
Caused by: org.hibernate.DuplicateMappingException: Table [user_history] contains physical column name [user_id] referred to by multiple logical column names: [user_id], [userId]
...
```

기본값으로 따지면 "User" 테이블의 "id" column 인데, "UserHistory" 테이블의 "userId" column 이 또 있으니까 모호하다는 뜻. 그래서 UserHistory 에서 userId 필드에 이름을 명시해주자

```java
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.persistence.*;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class UserHistory extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(name = "user_id")
  private Long userId;

  private String name;

  private String email;
}
```

나머지 `@JoinColumn` 의 속성으로 insertable, updatable 을 false 로 놓은 것은 해당 필드는 readonly, 즉 User 테이블을 통한 삽입/수정이 불가능하도록 하겠다는 것이다.

마무리 테스트 코드를 동작시켜보자.

```java
import com.fastcampus.jpa.bookmanager.domain.Gender;
import com.fastcampus.jpa.bookmanager.domain.User;
import com.fastcampus.jpa.bookmanager.domain.UserHistory;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import java.util.List;

@SpringBootTest
class UserRepositoryTest {

  @Autowired
  private UserRepository userRepository;

  @Autowired
  private UserHistoryRepository userHistoryRepository;

  @Test
  void select() {
  }

  @Test
  void pagingAndSortingTest() {
    System.out.println("findTop1ByName : " + userRepository.findTop1ByName("hyunwoo"));
    System.out.println("findTop1ByNameOrderByIdDesc : " + userRepository.findTop1ByNameOrderByIdDesc("hyunwoo"));
    System.out.println("findFirstByNameOrderByIdDescEmailAsc : " + userRepository.findFirstByNameOrderByIdDescEmailAsc("hyunwoo"));
    System.out.println("findFirstByNameWithSortParams : " + userRepository.findFirstByName("hyunwoo", Sort.by(Sort.Order.desc("id"), Sort.Order.asc("email"))));

    System.out.println("findByNameWithPaging : " + userRepository.findByName("hyunwoo", PageRequest.of(0, 1, Sort.by(Sort.Order.desc("id")))).getContent());
  }

  @Test
  void enumTest() {
    User user = userRepository.findById(1L).orElseThrow(RuntimeException::new);
    user.setGender(Gender.MALE);

    userRepository.save(user);

    userRepository.findAll().forEach(System.out::println);

    System.out.println(userRepository.findRawRecord().get("gender"));
  }

  @Test
  void prePersistTest() {
    User user = new User();
    user.setEmail("hyunwoo045@fastcampus.com");
    user.setName("Hyun Woo Kim");

    userRepository.save(user);

    System.out.println(userRepository.findByEmail("hyunwoo045@fastcampus.com"));
  }

  @Test
  void preUpdateTest() {
    User user = userRepository.findById(1L).orElseThrow(RuntimeException::new);

    System.out.println("as-is : " + user);

    user.setName("Hyun Woo Kim!");
    userRepository.save(user);

    System.out.println("to-be : " + userRepository.findAll().get(0));
  }

  @Test
  void userHistoryTest() {
    User user = new User();
    user.setEmail("hyunwoo-new@fastcampus.com");
    user.setName("hyunwoo-new");

    userRepository.save(user);

    user.setName("hyunwoo-new-new");

    userRepository.save(user);

    userHistoryRepository.findAll().forEach(System.out::println);
  }

  @Test
  void userRelationTest() {
    User user = new User();
    user.setName("david");
    user.setEmail("david@fastcampus.com");
    user.setGender(Gender.MALE);
    userRepository.save(user);
    user.setName("daniel");
    userRepository.save(user);
    user.setEmail("daniel@fastcampus.com");
    userRepository.save(user);

    List<UserHistory> result = userRepository.findByEmail("daniel@fastcampus.com").getUserHistories();
    result.forEach(System.out::println);
  }
}
```

UserHistory 의 column 3개가 잘 찍혀 나오는 것을 볼 수 있음.

<br/>

## N:1의 관계

UserHistory 의 데이터에서 User 를 참조하는 일이 그렇게 많지는 않겠지만, N:1 의 예제로 UserHistory - User 의 관계를 계속 사용해보자.

```java
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.persistence.*;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class UserHistory extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String email;

  @ManyToOne
  @ToString.Exclude
  private User user;
}
```

"user" 필드가 생기면서 기존에 작성되어 있던 userId 필드는 더 이상 필요하지 않게 되었음. UserHistory 객체의 구조가 변경되었으니 연관되어 있는 `UserEntityListener` 를 수정해주자.

```java
import com.fastcampus.jpa.bookmanager.domain.User;
import com.fastcampus.jpa.bookmanager.domain.UserHistory;
import com.fastcampus.jpa.bookmanager.repository.UserHistoryRepository;
import com.fastcampus.jpa.bookmanager.support.BeanUtils;

import javax.persistence.PostPersist;
import javax.persistence.PostUpdate;

public class UserEntityListener {
  @PostPersist
  @PostUpdate
  public void prePersistAndPreUpdate(Object o) {
    UserHistoryRepository userHistoryRepository = BeanUtils.getBean(UserHistoryRepository.class);

    User user = (User) o;

    UserHistory userHistory = new UserHistory();
    userHistory.setName(user.getName());
    userHistory.setEmail(user.getEmail());
    userHistory.setUser(user);

    userHistoryRepository.save(userHistory);
  }
}
```

이제 바로 setUser 를 통해 user 를 그대로 넣어줌.

이제 테스트를 실행한 후 DDL 을 보면

```shell
create table user_history (
    id bigint generated by default as identity,
    created_at timestamp,
    updated_at timestamp,
    email varchar(255),
    name varchar(255),
    user_id bigint,
    primary key (id)
)
```

user_id 필드가 생성되어 있는 것을 볼 수 있다.

이로써 User - UserHistory 의 양방향 관계가 성립됨.

<br/>

## M:N 연관 관계

한 Author 가 여러 책을 썼을 수 있고, 한 책에 여러 Author가 공동 집필하는 경우도 있다. 이를 M:N 관계라고 예시로 들고 코드를 작성해보자. `@ManyToMany` 어노테이션을 사용하여 관계를 구현한다.

- `Author.java`

```java
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
public class Author extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String country;

  @ManyToMany
  @ToString.Exclude
  private List<Book> books = new ArrayList<>();

  public void addBook(Book... book) {
    Collections.addAll(this.books, book);
  }
}
```

- Book.java

```java
import lombok.*;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Entity
@NoArgsConstructor
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class Book extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String category;

  private Long authorId;

  @OneToOne(mappedBy = "book")
  @ToString.Exclude
  private BookReviewInfo bookReviewInfo;

  @OneToMany
  @JoinColumn(name = "book_id")
  @ToString.Exclude
  private List<Review> reviews = new ArrayList<>();

  @ManyToOne
  @ToString.Exclude
  private Publisher publisher;

  @ManyToMany
  @ToString.Exclude
  private List<Author> authors = new ArrayList<>();


  public void addAuthor(Author... author) {
    Collections.addAll(this.authors, author);
  }
}
```

`addAuthor` 와 `addBook` 메서드에서 `Author...`, `Book...` 과 해당 객체의 배열을 표현하는 방식과 받은 배열을 한 번에 column 에 저장하는 방식도 기억해두는 것이 좋겠다.

- AuthorRepository.java

```java
package com.fastcampus.jpa.bookmanager.repository;

import com.fastcampus.jpa.bookmanager.domain.Author;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AuthorRepository extends JpaRepository<Author, Long> {
}
```

- AuthorRepositoryTest.java (테스트 코드)

```java
import com.fastcampus.jpa.bookmanager.domain.Author;
import com.fastcampus.jpa.bookmanager.domain.Book;
import org.assertj.core.util.Lists;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import javax.transaction.Transactional;

@SpringBootTest
class AuthorRepositoryTest {
  @Autowired
  private AuthorRepository authorRepository;

  @Autowired
  private BookRepository bookRepository;

  @Test
  @Transactional
  void manyToManyTest() {
    Book book1 = givenBook("책1");
    Book book2 = givenBook("책2");
    Book book3 = givenBook("개발책1");
    Book book4 = givenBook("개발책2");

    Author author1 = givenAuthor("martin");
    Author author2 = givenAuthor("steven");

    book1.addAuthor(author1);
    book2.addAuthor(author2);
    book3.addAuthor(author1, author2);
    book4.addAuthor(author1, author2);

    author1.addBook(book1, book3, book4);
    author2.addBook(book2, book3, book4);

    bookRepository.saveAll(Lists.newArrayList(book1, book2, book3, book4));
    authorRepository.saveAll(Lists.newArrayList(author1, author2));

    System.out.println("Authors through book : " + bookRepository.findAll().get(2).getAuthors());
    System.out.println("Books through author : " + authorRepository.findAll().get(0).getBooks());
  }

  private Book givenBook(String name) {
    Book book = new Book();
    book.setName(name);

    return bookRepository.save(book);
  }

  private Author givenAuthor(String name) {
    Author author = new Author();
    author.setName(name);

    return authorRepository.save(author);
  }
}
```

`@Transactional` 어노테이션은 lazy initialization 인지 lazy loading 이었는지의 오류를 해결하기 위해 테스트에 붙혔음.

`@ToString.Exclude` 같은 경우는 순환 참조로 인한 Stack Overflow 를 방지하기 위해서 붙힘.

테스트 까지도 잘 작성이 되긴 했지만, M:N 의 관계는 실제 서비스에서 로직을 구현하긴 매우 복잡하여 아주 특별한 니즈를 해소하기 위한 경우가 아니라면 M:N 관계를 설계하지 않는다. 다른 예시로 User - Product 의 관계에서 한 유저가 여러 물건을 구입할 수 있고, 같은 물건을 여러 유저가 구입할 수 있기 떄문에 M:N 의 관계라고 할 수 있는데, 복잡한 구조를 해소하기 위해서 중간에 Order 라는 객체를 추가하여 User - Order 는 1:N 의 관계 Order - Product 를 N:1 으로 풀어서 해소하는 경우가 일반적이다.

- `BookAndAuthor.java`

```java
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.persistence.*;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class BookAndAuthor extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @ManyToOne
  private Book book;

  @ManyToOne
  private Author author;
}
```

Order 와 같은 역할을 하는 중간 Entity 를 만들어주었음. 이제 Book, Author 객체를 약간 수정해야한다.

- `Book.java`

```java
import lombok.*;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Entity
@NoArgsConstructor
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class Book extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String category;

  private Long authorId;

  @OneToOne(mappedBy = "book")
  @ToString.Exclude
  private BookReviewInfo bookReviewInfo;

  @OneToMany
  @JoinColumn(name = "book_id")
  @ToString.Exclude
  private List<Review> reviews = new ArrayList<>();

  @ManyToOne
  @ToString.Exclude
  private Publisher publisher;

  @OneToMany
  @JoinColumn(name = "book_id")
  @ToString.Exclude
  private List<BookAndAuthor> bookAndAuthors = new ArrayList<>();


  public void addBookAndAuthors(BookAndAuthor... bookAndAuthors) {
    Collections.addAll(this.bookAndAuthors, bookAndAuthors);
  }
}
```

- `Author.java`

```java
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
public class Author extends BaseEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String country;

  @OneToMany
  @JoinColumn(name = "author_id")
  @ToString.Exclude
  private List<BookAndAuthor> bookAndAuthors = new ArrayList<>();

  public void addBookAndAuthors(BookAndAuthor... bookAndAuthors) {
    Collections.addAll(this.bookAndAuthors, bookAndAuthors);
  }
}
```

<br/>

## 갈무리

JPA 에서 직접 테이블도 만들어주고 메서드도 다 제공해주니까 아주 편리하긴 한데 설계된 데이터베이스 구조를 구현할 때에 관계를 '되기만 하는대로' 구현하여 의도치 않은 테이블이 생성된다거나 하여 성능을 저하시키는 일이 없도록 잘 학습하고 구현한 내용이 잘 동작하는지 쿼리를 검사하도록 하는 습관을 들이도록 하자.
