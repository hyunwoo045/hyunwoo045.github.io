---
title: "JSON Web Token - 로그인 세션 유지하기"
excerpt: "대표적인 서버 인증 방식인 JWT의 Access Token과 Refresh Token에 대해 정리합니다."

header:
  overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
  overlay_filter: 0.5

tags:
  - JWT

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

Velopert 님의 강의를 참고합니다.

[Express Server에서 JWT 구현하기](https://velopert.com/2448)

<br/>

## JWT (JSON Web Token)

JWT는 웹표준(RFC7519)으로 정보를 JSON 객체의 형태로 가볍고 필요한 정보를 모두 담으면서도 안정성 있게 두 개체 사이에서 전달 될 수 있도록 해줍니다. 많은 언어에서 지원되고, 필요한 모든 정보, 즉 토큰의 기본정보, 회원 정보와 같은 전달할 정보, 토큰의 유효성을 증명하는 signature 등을 담고 있으며 HTTP 헤더에 넣어 전송하거나 URL의 파라미터로 전송할 수 있어 아주 쉽게 전달이 가능합니다. 여러 분야에서 활용이 가능한 개념이며 특히나 회원 인증, 로그인 세션 유지와 같은 상황에서 아주 흔히 사용됩니다.

<br/>

### JWT 생김새

`aaaaaa.bbbbbb.cccccc`

`a 파트`: 헤더(header) <br/>
`b 파트`: 내용(payload) <br/>
`c 파트`: 서명(signature) <br/>

<br/>

### Header

헤더는 2가지의 정보를 지니고 있습니다.

- typ: 토큰의 타입을 지정.
- alg: 해싱 알고리즘을 지정. 보통 `HMAC SHA256` 혹은 `RSA`가 사용되며, 토큰을 검증할 때 사용되는 signature 부분에서 사용됨.

ex)

```json
// 알고리즘으로 `HMAC SHA256` 을 사용.
{
  "typ": "JWT",
  "alg": "HS256"
}
```

<br />

### Payload

정보(payload) 부분에는 토큰에 담을 정보가 들어있습니다. 여기서 정보의 한 조각을 `클레임(claim)` 이라고 부르며 key/value 와 같이 `name / value` 형식의 쌍으로 이루어져 있습니다. 이 부분에 여러 개의 클레임들을 넣을 수 있습니다.

클레임은 크게 세 분류로 나눌 수 있습니다.

- 등록된(`registered`) 클레임 <br/>
  토큰에 대한 정보를 담기 위해 이름이 이미 정해져 있는 클레임들. 이 것들을 사용하는 것은 모두 옵션이다. 아래와 같은 클레임들이 있음.
  - `iss` : 토큰 발급자
  - `sub` : 토큰 제목
  - `aud` : 토큰 대상자
  - `exp` : 토큰 만료시간
  - `nbf` : Not Before 를 의미하며, 토큰 활성 날짜와 비슷한 개념.
  - `iat` : 토큰이 발급된 시간.
  - `jti` : JWT의 고유 식별자. 중복 처리를 방지하기 위해 사용됨.
- 공개(`public`) 클레임
  충돌이 방지된 이름을 가지고 있어야 한다. 충돌을 방지하기 위해서는 클레임 이름을 URI 형식으로 지음.
- 비공개(`priavted`) 클레임
  보통 양 측 (클라이언트 <-> 서버) 협의 하에 사용되는 클레임 이름들. 공개 클레임과 달리 이름이 중복되어 충돌이 될 수 있으니 사용할 때 유의해야 함.

<br/>

### Signature

서명(signature) 부분에는 헤더의 인코딩값과 정보의 인코딩값을 합친 후 주어진 비밀키로 해쉬를 하여 생성합니다.

예를 들어 헤더를 인코딩한 값이 `aaaaaa` 이고 정보를 인코딩한 값이 `bbbbbb` 이라하면 `aaaaaa.bbbbbb`를 `secret`으로 해싱을 하고 `base64 인코딩`한 결과값이 서명 부분이 되겠습니다.

<br/>

## 프로젝트 생성 및 설정

express generator 를 이용하여 간단하게 express 환경을 구축합니다.

```
$ express jwt-tutorial --view=pug
```

아래와 같은 모듈을 추가 설치하겠습니다.

- jsonwebtoken : 이 프로젝트의 핵심 모듈. JWT를 손쉽게 생성하고 검증까지 해줌.
- mysql : 이 서버에서 MySQL 를 사용할 수 있게 해줌.

```
$ npm install jsonwebtoken
$ npm install mysql
```

## 라우터 설정

우선 간단하게 두 라우터를 만들어 로그인과 회원가입 요청에 대한 처리를 하도록 하겠습니다.

- `/auth/login` : 로그인 요청 처리
  POST형식으로 `{ username, password }` 를 전달받아서 username에 해당하는 password가 일치하는지 확인.
- `/auth/register` : 회원가입 요청 처리
  POST형식으로 `{ username, password }` 를 전달받아 username 이 중복되는지 확인한 후 데이터베이스에 새로운 레코드를 생성.

## User 객체 생성

데이터베이스 내에 회원 정보를 다루는 로직들은 재사용하기 편하도록 `User` 라는 객체를 생성하여 내부 메서드들로 제어할 수 있도록 하겠습니다. 로그인/회원가입을 처리하기 위한 기능은 `password 확인`, `username 중복확인`, `새로운 유저 정보 생성` 입니다. 또한, 데이터베이스와의 통신하는 과정이 있고 JWT 토큰 인증 방식이 추가되어 로그인/세션 인증 로직이 복잡해질테니 동기화를 해두도록 하겠습니다. `async/await` 문법을 이용합니다.

User 객체의 구현은 아래와 같이 하겠습니다. `User.verify(username, password)` 와 `User.create(username, password)`에서 비밀번호에 해당하는 부분을 해싱과 같은 기법으로 암호화 하지 않고 직접 데이터베이스에 삽입 및 비교하는 것은 매우 위험한 일이지만, JWT 의 튜토리얼이니 우선 간단하게 만듭니다.

```javascript
const mysql = require("mysql");
/* 
  dbconfig
  { host, username, password, database }
  형태로 mysql 서버에 접속하기 위한 기본 설정이며, 정보가 노출되지 않도록 숨깁니다.
*/
const dbconfig = require("../dbconfig");
const conn = mysql.createConnection(dbconfig);

const User = {
  create: (username, password) => {
    return new Promise((resolve, reject) => {
      conn.query(
        "INSERT INTO user (username, password) VALUES (?, ?);",
        [username, password],
        (err) => {
          if (err) reject(err);
          else {
            resolve();
          }
        }
      );
    });
  },
  verify: (username, password) => {
    return new Promise(function (resolve, reject) {
      conn.query(
        "SELECT password FROM user WHERE username=?",
        [username],
        (err, result) => {
          if (err) reject(err);
          else {
            if (result[0].password === password) resolve();
            else reject("WRONG PASSWORD");
          }
        }
      );
    });
  },
  findOneByUsername: (username) => {
    return new Promise((resolve, reject) => {
      conn.query(
        "SELECT COUNT(*) AS length FROM user WHERE username=?",
        [username],
        (err, result) => {
          if (err) reject(err);
          else {
            if (result[0].length !== 0) reject("INVALID USERNAME");
            else resolve();
          }
        }
      );
    });
  },
};

module.exports = User;
```

이에 맞춰 위에서 언급한 두 라우터도 아래와 같이 구현하도록 하겠습니다.

```javascript
const express = require("express");
const router = express.Router();
const User = require("../models/user");

router.post("/login", async (req, res) => {
  const { username, password } = req.body;
  try {
    const result = await User.verify(username, password);
    res.send(result);
  } catch (err) {
    res.send(err);
  }
});

router.post("/register", async (req, res) => {
  const { username, password } = req.body;
  try {
    await User.findOneByUsername(username);
    await User.create(username, password);

    res.send("REGISTED!");
  } catch (error) {
    res.send(error);
  }
});

module.exports = router;
```

<br/>

## JWT 토큰 발급

지금까지 사용자가 로그인/회원가입을 하고 로그인 요청을 하여 서버가 사용자 확인을 하는 과정까지 구현하였습니다. 이제 Access Token 과 Refresh Token 을 발급하고, 이를 활용하여 로그인 세션을 유지하는 로직을 구현하겠습니다. 과정은 아래의 그림과 같습니다.

![로그인API FLOW](https://blog.kakaocdn.net/dn/1Hwfo/btqzHUZwa84/y5NzKeHMOR3TKk8j1P01hK/img.png) <br/>
출처: [강디너의 개발 일지 - https://kdinner.tistory.com/60](https://kdinner.tistory.com/60)

1, 2번 과정까지 진행되었으니 3번을 작성해 보겠습니다.

`jwt.sign(payload, secret, options, [callback])` 함수를 사용하여 토큰을 발급 받을 것이며, 이 함수에 대한 자세한 설명은 아래와 같습니다.

- `callback` 이 전달되면 비동기적으로 작동하며, 인자는 `(err, token)` 이다. 전달되지 않으면 동기적으로 작동하며, JWT 를 문자열 형태로 리턴
- `payload` 는 객체, buffer, 문자열 형태로 전달 가능
- `secret` 은 서명을 만들 때 사용되는 알고리즘에서 사용하는 문자열 혹은 buffer 형태의 값
- `options`:
  - `algorithm`: default- `HS256`
  - `expiresIn`: 예) 60, `2 days`, `10h`, `30m` ...
  - `notbefore`: expiresIn 과 같은 형태
  - 등등 자세한 건 필요할 때 찾아보자..

위 내용을 바탕으로 JWT에 대한 메서드들을 정의하는 `JWTController` 객체를 생성하겠습니다. 토큰을 발급하는 `generate` 메서드를 아래와 같이 작성합니다.

```javascript
// jsonwebtoken 패키지를 사용하기 위해 등록해 줍니다.
const jwt = require("jsonwebtoken");

/* 
  secretKey 는 아래와 같은 정보이며, 보안 상 코드로 노출되지 않도록 숨깁니다.
  {
    secret: "thisismysecretkey",
    option: {
      algorithm: "HS256",
      expiresIn: "1h",
      issuer: "moonsdog"
    }
  }
*/
const secretKey = require("../key/jwtconfig");

const JWTController = {
  generate: (payload) => {
    const secret = secretKey.secret;
    const option = secretKey.option;
    return new Promise((resolve, reject) => {
      jwt.sign(payload, secret, option, (err, token) => {
        console.log(token);
        if (err) reject(err);
        resolve(token);
      });
    });
  },
};

module.exports = JWTController;
```

콜백 함수를 지정하면 비동기적으로 작동하므로 Promise 함수를 반환하게 하여 동기적으로 작동하게끔 합니다.

이제 라우터에서 로그인 요청이 들어올 시에 아이디/비밀번호가 맞는지 확인한 후 맞으면 토큰을 발급하도록 하겠습니다. 위에서 작성한 `/login` 에 대한 코드를 아래와 같이 수정하여, 사용자가 요청한 로그인 입력을 확인하고, 유효한 사용자라면 토큰을 발급하여 응답 헤더에 넣어 보내줍니다.

```javascript
// (....)
router.post("/login", async (req, res) => {
  const { username, password } = req.body;
  try {
    await User.verify(username, password);
    const token = await JWTController.generate({ username });
    res.send({
      message: "Logged in successfully",
      token,
    });
  } catch (err) {
    res.send(err);
  }
});
// (....)
```

- 결과

![토큰 발급](/images/2021-09-23-JWT/token_generate.png)

잘 나오네요!

[jwt.io](jwt.io) 에서 디코딩도 한 번 테스트 해보겠습니다.

![토큰 디코딩](/images/2021-09-23-JWT/token_generate_2.png)

전달했던 `payload.username` 이었던 `nickname01` 이 있는 것을 보아 payload 또한 잘 오고가는 것을 확인할 수 있습니다.

<br/>

## JWT 토큰 검증

로그인 세션 유지가 되도록 해보겠습니다. 유저가 새로고침을 하거나 창을 닫았다가 다시 접속할 경우, 웹 어플리케이션에는 유저의 정보가 남질 않지만 발급받았던 토큰을 `localStorage` 나 `Cookie` 에 저장해두고, 이를 검증하여 유효성 여부를 판단하는 방식으로 세션을 유지할 수 있겠습니다. 어떤 방식으로든 브라우저에서 가지고 있던 토큰을 서버에 검증 요청을 하면 이를 검증할 수 있도록 구현해보도록 하겠습니다. 위에서 생성했던 `JWTController` 에 `verify(token)` 메서드를 추가해주겠습니다.

```javascript
// (...)
verify: (token) => {
    return new Promise((resolve, reject) => {
      if (!token) reject("NOT LOGGED IN"); // 토큰이 없음.
      jwt.verify(token, secret, (err, decoded) => {
        if (err) reject("INVALID_TOKEN"); // 유효하지 않는 토큰
        resolve(decoded);
      });
    });
  },
```

요청을 받는 라우터를 추가합니다. `/check` 으로 지정하고, 로직을 구현하겠습니다.

```javascript
// (...)
const url = require("url");

router.get("/check", async (req, res) => {
  const _url = req.url;
  const queryData = url.parse(_url, true).query;
  const token = queryData.token;
  console.log(token);
  try {
    const decoded = await JWTController.verify(token);
    res.send({
      message: "Valid token",
      token,
      decoded,
    });
  } catch (err) {
    res.send(err);
  }
});
```

<br/>

유효한 토큰을 넣었을 때의 결과 모습

![verify 성공](/images/2021-09-23-JWT/token_verify.png)

유효하지 않은 토큰을 넣었을 때의 결과 모습

![유효하지 않은 토큰](/images/2021-09-23-JWT/token_verify_2.png)

토큰을 넣지 않았을 때 (로그인 한 기록이 없을 때)의 결과 모습

![로그인 안됨](/images/2021-09-23-JWT/token_verify_3.png)

각 세 분기마다 올바른 결과를 response 하는 것을 볼 수 있습니다.

지금까지 JWT, Access Token 과 `jsonwebtoken` npm 패키지를 이용하여 실제 발급 및 검증까지 해보았습니다. 실제 코드는 아래의 레파지토리에서 확인하실 수 있습니다.

[https://github.com/hyunwoo045/JWT-tutorial](https://github.com/hyunwoo045/JWT-tutorial)

감사합니다!

<br/>
