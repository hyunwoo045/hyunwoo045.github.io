---
title: "Node.js 란"
excerpt: "계속 쓰면서도 잘 알지 못했던 Node.js 에 대해 파봅니다!"

header:
  overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
  overlay_filter: 0.5

tags:
  - JavaScript
  - Node.js

toc: true
toc_label: "table of content"
toc_icon: "bars"
toc_sticky: true
---

계속 쓰면서도 잘 알지 못했던 Node.js 에 대해 파봅니다!

참고 자료: <br/>
[Node.js 란](https://perfectacle.github.io/2017/06/18/what-is-node-js/)<br/>
[(goorm) Node.js 소개 - Node.js 란](https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/21762/node-js-%EB%9E%80)<br/>
[(goorm) Node.js 소개 - 이벤트 기반 비동기 방식](https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/21763/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B0%A9%EC%8B%9D)<br/>
[컴파일과 고레벨, 저레벨 언어](https://blog.naver.com/ehcibear314/221228096291)<br/>
[컴파일러와 인터프리터의 차이](https://m.blog.naver.com/ehcibear314/221228200531)<br/>
[Node.js 개념 이해](https://urmaru.com/8)

# Node.js 란 ?

`Node.js` 는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다. Node.js 는 이벤트 기반, Non-Blocking I/O 모델을 사용해 가볍고 효율적입니다. Node.js의 패키지 생태계인 `npm`은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.

Node.js 에서 직접 정의한 내용입니다.

<h5>* 런타임:  프로그래밍 언어가 구동되는 환경.</h5><br/>

이 문장에 집중해보죠. `Node.js 는 이벤트 기반, Non-Blocking I/O 모델을 사용해 가볍고 효율적입니다.` 이벤트 기반으로 제작되었다는 것이 무슨 의미로, Non-Blocking I/O 모델은 무엇이길래 Node.js 가 뛰어난 성능을 가질 수 있도록 만들어 준 것일까요? 하나하나 뜯어보겠습니다.

<br/>

<h2> - Node.js 이전에 웹 애플리케이션은 어떻게 제작되었나? </h2>

최초의 CGI 라고 해서 펄 등의 스크립트로 개발했었습니다. 이 후에 ASP, JSP, PHP 등의 웹 개발을 위한 전용 언어들이 득세. 특히나 PHP 의 경우 오픈 소스로 개발의 용이함 덕분에 많은 웹 서비스들이 PHP 로 구현되었습니다. PHP 로 웹 애플리케이션을 제작하면 일반적으로 Apache 와 같은 웹 서버에서 동작하게 되었죠. 만약 사용자가 웹 서버에 연결을 요청하면 서버에서 일정한 메모리 공간을 사용하여 Thread 를 생성합니다. 이러한 특성 때문에 사용자가 많아지면 서버를 추가해야 했고, 이는 단순 서버 구매 비용 뿐 아니라 운영비, 트래픽 비용, 인건비 등을 더하는 문제를 발생시키고, 여러 대의 서버를 추가한다고 하더라도 사용자는 한 서버를 이용한다는 느낌을 받는 효과를 내어야 하기 때문에 모든 서버가 같은 데이터를 동기화 해야 한다는 문제도 발생했었습니다.

<br/>

## Thread vs Event

- <h2> Thread </h2>

위에서 말한듯, 노드 이전에는 대부분의 애플리케이션이 Thread 기반의 Blocking I/O 를 사용했다는 것을 알 수 있습니다. 많은 사용자들이 사용할 수 있게 하기 위해서 멀티 쓰레드를 사용할 수 밖에 없었고, 그로 인해 'Blocking I/O' 모델을 채택할 수 밖에 없어 대규모 요청을 동시에 처리하는 데에는 한계가 있을 수 밖에 없었습니다.

![ㅇㅇ](https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488263625769_image.png)<br/>
출처: [Node.js 란 - goorm](https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/21762/node-js-%EB%9E%80)

Blocking I/O 모델은 자원의 일관성을 지키기 위해 존재합니다. 여러 프로세스가 한 자원(메모리 안의 특정 값과 같은 리소스)에 대해 사용하려 할 때, 특정 프로세스가 그 자원을 사용 (읽기, 쓰기 등)을 하고 있다면 해당 프로세스가 사용을 마칠 때 까지는 다른 프로세스들이 그 자원을 사용하지 못하고 기다려야 합니다. 위의 그림을 참고해 주세요. 어플리케이션은 시스템의 어떤 자원을 사용하기 위해 "Blocked!" 라고 표시 되어 있는 기간 동안 다른 프로세스가 자원 사용을 마치기를 기다리며 '아무것도' 하지 못하고 있는 상황인 것입니다.

- <h2> Multi-Thread </h2>

이러한 문제를 떠안으면서도 웹 서버와 같이 다수의 요청을 빠르게 처리하기 위해서 멀티 쓰레드라는 개념을 사용할 수 밖에 없게 됩니다. 멀티 쓰레드는 말 그대로 여러 쓰레드가 동시에 실행되는 것입니다. 사실은 엄밀히 따지면 동시에 실행되는 것은 아니고, 여러 쓰레드가 한 CPU를 공유하고 CPU 스케쥴링에 의해 번갈아가며 동작하여 마치 여러 쓰레드가 동시에 실행되는 것처럼 보이는 것입니다. (아주 간단히 설명하였지만, 간단한 내용이 아니고 Node.js 에 핵심적인 내용이 아니므로 자세한 내용은 생략하겠습니다.)

아무리 멀티 쓰레딩을 통해 여러 요청을 동시에 처리 할 수 있게 되었다고 한 들, 요청이 많아져 쓰레드가 많아지면 CPU 또한 '자원' 이기 때문에 일부 Thread는 다른 Thread 들이 CPU 사용을 마치기를 '대기'하며 아무것도 하지 못하고 시간을 낭비하게 됩니다.

- <h2> Event </h2>

이를 해결하기 위해 Node.js 가 등장합니다. Single Thread 와 이벤트 기반의 Non-Blocking I/O 처리로 성능을 끌어 올립니다. 기존에는 I/O 작업이 발생하면 I/O 작업 처리에 대한 응답을 기다려야 했지만 노드는 바로 다음 작업을 실행해버립니다. 응답을 기다려야 하는 작업들의 경우는 따로 `이벤트` 로써 처리하는 방식을 채택합니다.

- Event Loop

그렇기 떄문에 Node.js 는 반대로 동기화의 문제를 가지게 되었습니다. 아래의 코드를 실행했을 때 어떤 결과가 나올까요?

```javascript
let a = 1,
  b = 2;

console.log(a); // ---- (1)

setTimeout(() => {
  b = 4;
  console.log(b); // ---- (2)
}, 500);

console.log(b); // ---- (3)
```

비동기 I/O 처리 방식이기 때문에 `(1)`이 실행되고 0.5초 뒤에 내부 함수(콜백 함수)를 실행하라는 내용을 건너뛰고 `(3)`이 실행되고 0.5초 뒤에 `(2)`가 실행됩니다. 따라서 `1 4 4`가 출력 될 것이라는 예상과 달리 `1 2 4`가 출력됩니다.

다른 예를 들어 데이터베이스에서 값을 받아와 그 값을 처리하는 일을 해야 했다고 가정해봅시다.

```javascript
let value = null;

db.query(_query, (err, result) => {
  value = result;
});

console.log(value);
```

(물론 내부 콜백 함수에 `console.log(result)` 하면 되지만, 예시를 위해 위와 같이 작성합니다.) <br/>

`value` 는 거의 대부분 `null` 이 출력될 것입니다. db에 접속하고 query문을 통해 값을 받아 오는 동안에 이미 비동기적으로 `value` 를 출력해버리기 때문이죠.

이러한 문제를 해결하기 위해서 이벤트 루프라는 동작 방식으로 노드는 동기화 문제를 해결합니다. 특정 동작이 완료 되었을 때에 실행되도록 지정된 동작들 (콜백 함수 등)을 `이벤트 큐(Event Queue)` 에 쌓아 둡니다. `호출 스택(Call Stack)`에 쌓여있던 동작들이 모두 수행되고 이벤트 루프가 돌기 시작하면서 `이벤트 큐`에 있는 동작들을 처리합니다. (이벤트 큐에 있던 동작들은 다시 호출 스택에 쌓아서 쭉 실행하고 다시 이벤트 루프 동작?)

웹 서버의 경우를 따져보겠습니다. 웹 서버가 실행되면 내부에서 서버 동작에 필요한 모든 함수들이 실행되고 이벤트 루프가 돌기 시작합니다. 클라이언트가 서버에 요청을 넣으면 이를 이벤트 루프가 감지하고 워커 쓰레드를 생성하여 실행합니다. 이벤트 루프는 해당 쓰레드의 응답을 기다리지 않고 즉시 루프로 돌아와서 다른 요청을 기다립니다.

이렇게 가볍게 훑기엔 너무나도 중요한 내용이기에 `호출 스택, 실행 컨텍스트, 이벤트 루프` 등에 대해서 따로 공부하고 글을 작성해보도록 하겠습니다.

<br/>

## Chrome V8 Javascript Engine

Node.js 의 정의로 다시 돌아가서 다른 문장을 살펴봅시다.

" `Node.js` 는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다. "

V8 엔진은 무엇일까요? 왜 탄생하게 되었을까요? 이 모든 궁금증에 대한 해답은 조금 먼 길을 떠나야 할 지도 모릅니다..

<br/>

- ## 컴파일러 vs 인터프리터

우리는 프로그램을 작성할 때에 사람이 이해할 수 있는 수준의 언어를 사용합니다. 소위 `고급 프로그래밍 언어`, `High-level Programming Language` 라고 하죠. 컴퓨터나 기계는 사람의 언어를 사용하지 않습니다. 하지만 프로그래밍의 주된 목적은 컴퓨터나 기계를 제어하기 위함입니다. 우리의 프로그래밍 언어를 그들이 이해할 수 있는 언어 (즉, 기계어, Machine Language)로 번역해야 하고 그 일을 담당해주는 것이 `컴파일러` 이고 `인터프리터` 입니다.

둘의 궁극적인 목적은 같습니다. <b>고급 프로그래밍 언어를 기계어로 변환한다.</b> 그렇다면 둘은 어떤 차이가 있을까요?

가장 기본적인 둘의 차이는 컴파일러는 전체 소스 코드를 보고 명령어를 수집하고 재구성하는 반면에 인터프리터는 소스코드와 각 행을 연속적으로 분석하고 실행합니다. 여기에 인터프리터에는 특이한 특징이 하나 있는데, 인터프리터는 고레벨 언어를 바로 기계어로 바꾸는 것이 아닌 중간 형태로 한번 변환 한 다음 실행한다는 차이가 있습니다.

![Compiler vs Interpreter](https://mblogthumb-phinf.pstatic.net/MjAxODAzMTNfMzEg/MDAxNTIwOTMyMjgxNTYx.31JjAtxFs6-zCTs8M-XUKo_Lvsm1PsxFZ1MPQTWVmosg.rXo2xTreC5YsfBDjcMaVQC_-5oyoCtwzpIrz0yOzSV0g.JPEG.ehcibear314/Compilervrsinterpreter.JPG?type=w800)<br/>
출처: [컴파일러와 인터프리터의 차이](https://m.blog.naver.com/ehcibear314/221228200531)

이러한 특징 때문에 인터프리터는 컴파일러와 다른 아래와 같은 특성이 있습니다.

1. 대부분의 측면에서 인터프리터가 컴파일러보다 느리다.
2. 인터프리터는 각 행을 실행하는 도중에 에러가 생기면 그 곳에서 멈추고 에러를 발생한다. 보안적인 관점에서 도움이 된다.

<br/>

- ## Javascript

Javascript 는 `인터프리터` 언어 입니다. HTML 로 작성된 문서의 DOM 을 제어하기 위해, 즉 HTML 페이지를 동적으로 만들기 위해서 탄생한 언어입니다. 1995년 탄생하였을 당시 아주 획기적인 발명이었지만 시간이 지날수록 여러 명확한 문제점들이 드러났는데, 가장 큰 문제는 <b>"너무 느리다"</b>는 것이었습니다. `인터프리터` 언어의 특성이었을 수도, 혹은 그 당시의 Javascript 엔진의 문제였을지도 모릅니다.

구글이 `Google Maps` 를 개발하며 이 명확한 한계점을 느끼게 되고 2009년에 V8 엔진을 출시합니다. 이 엔진의 가장 강력한 기능은 <b>필요한 부분만 컴파일한다</b>는 것입니다. 위에서 컴파일러와 인터프리터의 번역 방식의 차이를 보았었죠. 여기서 컴파일 방식의 성능이 월등히 좋은 대표적인 사례를 소개하겠습니다.

```javascript
function sum() {
  let result = 0;
  for (let i = 0; i <= 10; i++) {
    result += i;
  }
  return result;
}

sum();
sum();
sum();
sum();
```

컴파일러는 sum 함수의 결과를 55로 기억합니다. 딱 한 번만 10번의 loop를 거친 후 다시 sum 함수가 호출되면 loop 를 돌지 않고 55 를 출력해줍니다. 인터프리터는 그와 반대로 매 번 함수가 호출될 때마다 10번 loop 합니다.

인터프리터의 입장에서 위와 같은 코드는 너무 불합리합니다. 누군가가 sum 함수의 결과를 변수에 저장해주고, sum 함수가 호출될 때마다 변수를 불러와서 값을 출력해주면 얼마나 좋았을까요. 이런 인터프리터의 입장에서 불합리한 코드를 V8 엔진이 해결해줍니다.

Chrome V8 엔진이 어떻게 동작하는지 아주 살짝 살펴보겠습니다. 우선 엔진이 실행할 JS 파일을 받습니다. 그리고 파싱하여 AST(Abstract Syntax Tree)를 구축하는 과정을 거칩니다. 다음에 인터프리터가 코드를 읽으며 실행합니다. 이를 프로파일러가 지켜보다가 최적화 할 수 있는 코드를 컴파일러에게 전달하고 반복되서 실행되는 코드 블록을 최적화하여 원래 있던 코드와 바꿔줍니다.

위와 같이 인터프리터 방식으로 코드를 실행하고 필요할 때 컴파일 하는 방법을 JIT(Just-In-Time) 컴파일 이라고 합니다.

이렇게 Javascript의 속도 문제가 해결되면서 `Node.js` 프로젝트가 시작됩니다. 이제 어느 정도 `nodejs 는 V8 엔진 위에 만들어진 JS 런타임이다` 는 말의 의미가 이해되기도 합니다.

<br/>

---

Node.js 란? 이라는 아주 간단한 질문에 대해 세세한 질문들을 가지치다 보니 산으로 많이 간 느낌이네요.. 틀린 부분도 있을 것입니다. 잘못된 내용은 수정할 수 있도록 지적 부탁드립니다.

hyunwoo045@gmail.com

감사합니다 :D

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]: https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
